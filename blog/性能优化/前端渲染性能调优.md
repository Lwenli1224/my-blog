# 前端渲染性能调优

## 基础概念

### 网页渲染流程

- 加载网页，parseHTML
- HTML解释器将HTML字符转为为一个个token，最后形成DOM树
- 遇到css外链标签，调用cssLoader（待验证）
- 遇到script外链标签，调用scriptLoader（待验证），**停止DOM树创建**
- 遇到资源标签，调用对应的资源加载器
- 遇到script内联标签，调用js解释器，**停止DOM树创建**
- 遇到css内联标签，调用css解释器
- 激活“DOMContentLoad”事件
- 开始进入真正的渲染，要注意的是，以下环节在DOM树构建中也会触发，是由于浏览器加载和渲染是不断进行的（待验证）
- **layout**：CSS规则加上DOM，通过布局计算成为RenderObject，这一环节在网页的生命周期中常反复经过
- **layer**：根据网页层次，创建RenderLayer树
- **paint**：创建RenderLayer的同时，绘制每层内容
- **composite**：将所有层的绘制结果合成为一个图像



## 影响渲染性能的因素

### javascript执行效率




### 样式计算的范围及复杂度

### DOM数量

### 布局复杂度

### 绘制区域

### 渲染层数量

### 用户交互处理函数

## 评估渲染性能

## 渲染性能调优实践

## 常规调优方法对性能的影响实测

### js放在页面底部

由于加载和执行javascript，会停止DOM树的创建，所以这就是老生常谈的将js文件放在body底部的原因，加速页面显示的效率。

然而实测并不是期望的效果。

新建一个计算密集的js文件`heavy.js`：

```javascript
// 执行1亿次，大约用时900-1000ms
var i = 100000000;
while (i) {
    i--;
    Math.exp(Math.sqrt(i));
}
```

...

建立空文件`a.js b.js`，放置在`<head>`头部

浏览器经过环节如下：

1. 请求html文件
2. 接受html文件
3. parse html[0...4]
4. send request，获取`a.js b.js`
5. 先获取到了`b.js`，之后获取	`a.js`
5. 根据顺序evaljs，先解析`a.js`
6. parse html[5...5]
7. 此时获取到了`b.js`，解析`b.js`
8. 继续parse html直到最后，激活`DOMContentLoaded`
9. 开始CSS计算，布局测试
10. 绘制层，合成层

要注意的是，在浏览器发送获取`a.js b.js`的request时，parse html仅仅解析到了第4行（`a.js b.js`的标签位置在第6、7行），出现这种现象的原因是，Webkit内核为了提高资源加载的速度，达到并行加载，使用了HTML预扫描器。HTML预扫描器与HTML Parser不同，不解析DOM以及创建DOM树，所以速度很快，预先扫描所需要加载的资源，提前进行网络请求获取。（待验证）

使用此种方案，在html很复杂时，会出现的关键事件顺序如下：

Load Complete -> DOMContentLoad -> FirstPaint 

可以发现，并不是一个良好的状态，真正渲染图像的时机滞后。为了让用户更快速的看到页面，我们应该尽可能提高FirstPaint的时机，和减少渲染工作的复杂度。


## 总结

